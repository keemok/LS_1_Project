using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing.Imaging;
using MySql.Data.MySqlClient;
using Newtonsoft.Json;

namespace Syscon_Solution.LSprogram
{
    public partial class missionEdit : UserControl
    {

        LSprogram.mainForm mainform;
        //public static missionEdit _instance;
        //public static missionEdit instance
        //{
        //    get
        //    {
        //        if (_instance == null)
        //        {
        //            _instance = new missionEdit();

                    
        //        }
        //        return _instance;
        //    }
        //}

        public missionEdit(LSprogram.mainForm form)
        {
            mainform = form;
        }

        public missionEdit()
        {
            
            
            // This line of code is generated by Data Source Configuration Wizard
            // Fill a SqlDataSource
            
        }
        public void oninit()
        {
            InitializeComponent();
            sqlDataSource1.Fill();
            aboutMove();
        }
        private void toggleSwitch1_Toggled(object sender, EventArgs e)
        {
   
        }
        private double Wheelratio = 1.0F;
        private Point clickPoint;
        private Point imgPoint;
        private Rectangle imgRect;
        public void aboutMove()
        {

            pb_map.MouseWheel += new MouseEventHandler(picturebox_Wheel);
            imgPoint = new Point(pb_map.Width / 2, pb_map.Height / 2);
            imgRect = new Rectangle(0, 0, pb_map.Width, pb_map.Height);
            Wheelratio = 1;
            clickPoint = imgPoint;
        }
        private void picturebox_Wheel(object sender, MouseEventArgs e)
        {
            int lines = e.Delta * SystemInformation.MouseWheelScrollLines / 120;
            PictureBox pb = (PictureBox)sender;

            if (lines > 0)
            {
                Wheelratio *= 1.1F;
                if (Wheelratio > 100.0) Wheelratio = 100.0;
            }
            else if (lines < 0)
            {
                Wheelratio *= 0.9F;
                if (Wheelratio < 1) Wheelratio = 1;
            }

            imgRect.Width = (int)Math.Round(imgRect.Width * ratio);
            imgRect.Height = (int)Math.Round(imgRect.Height * ratio);
            imgRect.X = (int)Math.Round(pb.Width / 2 - imgPoint.X * ratio);
            imgRect.Y = (int)Math.Round(pb.Height / 2 - imgPoint.Y * ratio);

            pb_map.Invalidate();
        }
        int width;
        int height;
        float resoultion1;
        float ori_x;
        float ori_y;
        float ratio = 10;
        float translate_x = 0;
        float translate_y = 0;
        float dOrignX = 0;
        float dOrignY = 0;
        int nSourceMapWidth = 0;
        int nSourceMapHeight = 0;
        MySqlConnection conn;
        byte[] sourceMapValues;
        private void simpleButton7_Click(object sender, EventArgs e)
        {
            string strConn = "Server=192.168.20.28;Database=ridis_db;Uid=syscon;Pwd=r023866677!";
            conn = new MySqlConnection(strConn);
            conn.Open();
            selectMap();
            conn.Close();
        }
        MapState mapstate = new MapState();
        private void selectMap()
        {

            DataSet ds = new DataSet();
            string sql = "select * from map_t order by idx DESC limit 1";
            MySqlDataAdapter adapter = new MySqlDataAdapter(sql, conn);
            string temp = "";
            adapter.Fill(ds, "map_t");
            if (ds.Tables.Count > 0)
            {
                foreach (DataRow r in ds.Tables[0].Rows)
                {
                    //Console.WriteLine(r["map_data"]);
                    mapstate = JsonConvert.DeserializeObject<MapState>(r["map_data"].ToString());
                    //Console.WriteLine(mapstate.data);
                }
            }
            Console.WriteLine(mapstate.data.Count());
            width = mapstate.info.width;
            height = mapstate.info.height;
            resoultion1 = (float)mapstate.info.resolution;
            ori_x = (float)mapstate.info.origin.position.x;
            ori_y = (float)mapstate.info.origin.position.y;
            sourceMapValues = mapstate.data.ToArray().Select(x => (byte)x).ToArray();
            for (var y = 0; y < width * height; y++)
            {
                sourceMapValues[y] = (byte)mapstate.data[y];

            }
            MapInfoComplete();
        }
        public void MapInfoComplete()
        {
            try
            {
                nSourceMapWidth = width;
                nSourceMapHeight = height;

                Size sz = pb_map.Size;
                if (sz.Width > width)
                {
                    float tmpratio_w = (float)(sz.Width) / width;
                    float tmpratio_h = 0;
                    if (sz.Height > height)
                    {
                        tmpratio_h = (float)(sz.Height) / height;
                    }
                    if (tmpratio_w > tmpratio_h)
                        ratio = tmpratio_h;
                    else ratio = tmpratio_w;

                }
                onMapDisplay1();

            }
            catch (Exception ex)
            {
                Console.Out.WriteLine("MapInfoComplete err :={0}", ex.Message.ToString());
            }
        }
        public void onMapDisplay1()
        {
            try
            {
                Bitmap bmSource = new Bitmap(nSourceMapWidth, nSourceMapHeight, PixelFormat.Format32bppRgb);//, PixelFormat.Format8bppIndexed);

                Bitmap bmMergeOKSource = new Bitmap(nSourceMapWidth, nSourceMapHeight, PixelFormat.Format32bppRgb);//, PixelFormat.Format8bppIndexed);

                Map_Robot_Image_Processing2(ref bmSource, bmSource.Width, bmSource.Height, sourceMapValues, "gray");

                dOrignX = ((ori_x * -1) / resoultion1);
                dOrignY = ((ori_y) / resoultion1);

                if (dOrignY < 0) dOrignY *= -1;
                dOrignY = nSourceMapHeight - dOrignY;

                dOrignX = dOrignX * ratio + translate_x;
                dOrignY = dOrignY * ratio + translate_y;

                Image imgSource_Chg;
                imgSource_Chg = ZoomIn(bmSource, ratio);

                Bitmap translateBmp = new Bitmap(imgSource_Chg.Width, imgSource_Chg.Height);
                translateBmp.SetResolution(imgSource_Chg.HorizontalResolution, imgSource_Chg.VerticalResolution);

                Graphics g = Graphics.FromImage(translateBmp);
                g.TranslateTransform(translate_x, translate_y);
                g.DrawImage(imgSource_Chg, new PointF(0, 0));

                pb_map.Image = translateBmp;

                pb_map.Invalidate();

                bmSource.Dispose();
                bmMergeOKSource.Dispose();



            }
            catch (Exception ex)
            {
                Console.Out.WriteLine("onMapDisplay1 err :={0}", ex.Message.ToString());
            }
        }
        Image ZoomIn(Image img, double nresolution)
        {

            Bitmap bmp = new Bitmap(img, (int)(img.Width * nresolution), (int)(img.Height * nresolution));
            bmp.SetResolution((int)(bmp.VerticalResolution * nresolution), (int)(bmp.HorizontalResolution * nresolution));
            Graphics g = Graphics.FromImage(bmp);

            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
            return bmp;
        }
        private void Map_Robot_Image_Processing2(ref Bitmap bmSource, int Width, int Height, byte[] sourcemapvalue, string strfiltername)
        {
            try
            {
                //
                // 여기서 부터 Picture Box의 이미지를 복사해 오는 부분입니다
                //
                Rectangle rect = new Rectangle(0, 0, bmSource.Width, bmSource.Height);
                System.Drawing.Imaging.BitmapData bmpData =
                    bmSource.LockBits(rect, System.Drawing.Imaging.ImageLockMode.ReadWrite,
                    bmSource.PixelFormat);

                IntPtr ptr = bmpData.Scan0;
                byte[] rgbValues;


                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    rgbValues = new byte[Width * Height * 4];
                }
                else
                {
                    rgbValues = new byte[Width * Height];
                }

                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    var k = 0;
                    for (var y = 0; y < Height; y++)
                    {
                        for (var x = 0; x < Width; x++)
                        {
                            byte btemp = sourcemapvalue[y * Width + x];

                            if (strfiltername == "gray" || strfiltername == "cost" || strfiltername == "globalcost")
                            {
                                //if (btemp == 0) btemp = 0xff;
                                //else if (btemp == 0xff) btemp = 0xf0;
                            }
                            else
                            {
                                if (btemp == 0) btemp = 0xff;
                            }


                            #region  gray filter 그레이는 r,g,b가 동일 값으로 들어감
                            if (strfiltername == "gray" || strfiltername == "cost" || strfiltername == "globalcost")
                            {
                                rgbValues[k] = btemp;
                                rgbValues[k + 1] = btemp;
                                rgbValues[k + 2] = btemp;
                            }


                            #endregion

                            k += 4;
                        }
                    }
                }

                else
                {
                    for (int i = 0; i < Width * Height; i++)
                    {
                        rgbValues[i] = sourcemapvalue[i];
                    }
                }

                //
                // 여기까지가 Marshal Copy로 rgbValues 버퍼로 영상을 Copy해 오는 부분입니다.
                //

                //
                // 여기서부터 2차원 배열로 1차원 영상을 옮기는 부분입니다
                //
                double[,] Source = new double[Width, Height];
                double[,] Target = new double[Width, Height];

                int XPos, YPos = 0;
                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    for (int nH = 0; nH < Height; nH++)
                    {
                        XPos = 0;

                        if (strfiltername == "gray")
                            XPos = 0; //gray xpos

                        for (int nW = 0; nW < Width; nW++)
                        {
                            Source[nW, nH] = rgbValues[XPos + YPos];
                            Target[nW, nH] = rgbValues[XPos + YPos];
                            XPos += 4;
                        }
                        YPos += Width * 4;
                    }
                }
                else
                {
                    for (int nH = 0; nH < Height; nH++)
                    {
                        XPos = 0;
                        for (int nW = 0; nW < Width; nW++)
                        {
                            Source[nW, nH] = rgbValues[XPos + YPos];
                            Target[nW, nH] = rgbValues[XPos + YPos];
                            XPos++;
                        }
                        YPos += Width;
                    }
                }

                //
                // 여기까지는 2차원 배열로 영상을 복사하는 부분입니다.
                //

                //좌우반전//
                int nconvert = 0;

                //상하반전
                nconvert = 0;
                double[,] bconvertTarget = new double[Width, Height];
                for (int nh = 0; nh < Height; nh++)
                {
                    nconvert = 0;
                    for (int nw = 0; nw < Width; nw++)
                    {
                        bconvertTarget[nw, Height - nh - 1] = Target[nw, nh];
                        //nconvert++;
                    }
                }



                //
                // 여기서 부터는 2차원 배열을 다시 1차원 버터로 옮기는 부분입니다
                //

                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    rgbValues = new byte[Width * Height * 4];
                }
                else
                {
                    rgbValues = new byte[Width * Height];
                }

                YPos = 0;
                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    for (int nH = 0; nH < Height; nH++)
                    {
                        XPos = 0;
                        for (int nW = 0; nW < Width; nW++)
                        {

                            #region  gray filter 그레이는 r,g,b가 동일 값으로 들어감
                            if (strfiltername == "gray")
                            {
                                bconvertTarget[nW, nH] = (byte)(255 - (255 * bconvertTarget[nW, nH]) / 100);
                                rgbValues[XPos + YPos] = (byte)bconvertTarget[nW, nH];
                                rgbValues[XPos + YPos + 1] = (byte)bconvertTarget[nW, nH];
                                rgbValues[XPos + YPos + 2] = (byte)bconvertTarget[nW, nH];
                            }

                            #endregion

                            if (strfiltername == "globalcost")
                            {
                                bconvertTarget[nW, nH] = (byte)(255 - (255 * bconvertTarget[nW, nH]) / 100);
                                rgbValues[XPos + YPos] = (byte)bconvertTarget[nW, nH];
                                rgbValues[XPos + YPos + 1] = (byte)bconvertTarget[nW, nH];
                                rgbValues[XPos + YPos + 2] = (byte)bconvertTarget[nW, nH];
                            }

                            #region  cost map filter
                            if (strfiltername == "cost")
                            {
                                //cost map 색상 테스트
                                if (bconvertTarget[nW, nH] < 36)
                                {
                                    rgbValues[XPos + YPos] = 0xff;
                                    rgbValues[XPos + YPos + 1] = 0xff;
                                    rgbValues[XPos + YPos + 2] = 0xff;
                                    rgbValues[XPos + YPos + 3] = 255;
                                }

                                else if (bconvertTarget[nW, nH] == 100) // lethal obstacle values (100) in purple
                                {
                                    rgbValues[XPos + YPos] = 255;
                                    rgbValues[XPos + YPos + 1] = 0;
                                    rgbValues[XPos + YPos + 2] = 255;
                                    rgbValues[XPos + YPos + 3] = 255;
                                }
                                else if (bconvertTarget[nW, nH] > 101 && bconvertTarget[nW, nH] < 128) // illegal positive values in green
                                {
                                    rgbValues[XPos + YPos] = 0;
                                    rgbValues[XPos + YPos + 1] = 255;
                                    rgbValues[XPos + YPos + 2] = 0;
                                    rgbValues[XPos + YPos + 3] = 255;
                                }

                                else if (bconvertTarget[nW, nH] > 155 && bconvertTarget[nW, nH] < 255) // illegal negative (char) values in shades of red/yellow
                                {
                                    rgbValues[XPos + YPos] = 255;
                                    rgbValues[XPos + YPos + 1] = (byte)((255 * (bconvertTarget[nW, nH] - 128)) / (254 - 128));
                                    rgbValues[XPos + YPos + 2] = 0;
                                    rgbValues[XPos + YPos + 3] = 255;
                                }
                                else
                                {
                                    rgbValues[XPos + YPos] = 255;
                                    rgbValues[XPos + YPos + 1] = 255;
                                    rgbValues[XPos + YPos + 2] = (byte)bconvertTarget[nW, nH];
                                    rgbValues[XPos + YPos + 3] = 255;
                                }


                            }
                            #endregion

                            XPos += 4;
                        }
                        YPos += Width * 4;

                    }
                }
                else
                {
                    for (int nH = 0; nH < Height; nH++)
                    {
                        XPos = 0;
                        for (int nW = 0; nW < Width; nW++)
                        {
                            rgbValues[XPos + YPos] = (byte)bconvertTarget[nW, nH];

                            XPos++;
                        }
                        YPos += Width;
                    }
                }


                //
                // 다시 Marshal Copy로 Picture Box로 옮기는 부분입니다
                //
                if (bmSource.PixelFormat == PixelFormat.Format32bppArgb || bmSource.PixelFormat == PixelFormat.Format32bppRgb)
                {
                    System.Runtime.InteropServices.Marshal.Copy(rgbValues, 0, ptr, Width * Height * 4);
                }
                else
                {
                    System.Runtime.InteropServices.Marshal.Copy(rgbValues, 0, ptr, Width * Height);
                }

                bmSource.UnlockBits(bmpData);

                //System.Drawing.Rectangle cropArea = new System.Drawing.Rectangle(6, 6, Width - 12, Height - 12);
                System.Drawing.Rectangle cropArea = new System.Drawing.Rectangle(0, 0, Width, Height);
                Bitmap bmpTemp = bmSource.Clone(cropArea, bmSource.PixelFormat);
                bmSource.Dispose();
                bmSource = null;
                bmSource = (Bitmap)(bmpTemp.Clone());
            }
            catch (Exception ex)
            {
                Console.Out.WriteLine("Map_Robot_Image_Processing2 err :={0}", ex.Message.ToString());
            }

        }

        private void pb_map_Paint(object sender, PaintEventArgs e)
        {

            try
            {
                Bitmap bmSource = new Bitmap(nSourceMapWidth, nSourceMapHeight, PixelFormat.Format32bppRgb);//, PixelFormat.Format8bppIndexed);

                Bitmap bmMergeOKSource = new Bitmap(nSourceMapWidth, nSourceMapHeight, PixelFormat.Format32bppRgb);//, PixelFormat.Format8bppIndexed);

                Map_Robot_Image_Processing2(ref bmSource, bmSource.Width, bmSource.Height, sourceMapValues, "gray");

                dOrignX = ((ori_x * -1) / resoultion1);
                dOrignY = ((ori_y) / resoultion1);

                if (dOrignY < 0) dOrignY *= -1;
                dOrignY = nSourceMapHeight - dOrignY;

                dOrignX = dOrignX * (float)Wheelratio + translate_x;
                dOrignY = dOrignY * (float)Wheelratio + translate_y;

                Image imgSource_Chg;
                imgSource_Chg = ZoomIn(bmSource, (float)Wheelratio);

                Bitmap translateBmp = new Bitmap(imgSource_Chg.Width, imgSource_Chg.Height);
                translateBmp.SetResolution(imgSource_Chg.HorizontalResolution, imgSource_Chg.VerticalResolution);

                Graphics g = Graphics.FromImage(translateBmp);
                g.TranslateTransform(translate_x, translate_y);
                g.DrawImage(imgSource_Chg, new PointF(0, 0));

                pb_map.Image = translateBmp;

                pb_map.Invalidate();

                bmSource.Dispose();
                bmMergeOKSource.Dispose();



            }
            catch (Exception ex)
            {
                Console.Out.WriteLine("onMapDisplay1 err :={0}", ex.Message.ToString());
            }
        }

        private void simpleButton3_Click(object sender, EventArgs e)
        {
            try
            {
                missioneditDlg missionedit = new missioneditDlg();
                //mainform.dbBridge.
                if(missionedit.ShowDialog() == DialogResult.OK)
                {
                    string missionname = missionedit.strMissionName;
                    string missionid = missionedit.strMissionID;
                    string missionatc = missionedit.strMissionATC;

                    WorkFlowGoal missiondata = new WorkFlowGoal();

                    missiondata.work_id = missionid;
                    missiondata.action_start_idx = 0;
                    missiondata.loop_flag = 1;

                    Action act = new Action();
                    act.action_type = (int)Data.ACTION_TYPE.Goal_Point;

                    act.action_args.Add(0);
                    act.action_args.Add(0);
                    act.action_args.Add(0);
                    ParameterSet paramset = new ParameterSet();
                    paramset.param_name = "max_trans_vel";
                    paramset.type = "float";
                    paramset.value = "0.7";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "xy_goal_tolerance";
                    paramset.type = "float";
                    paramset.value = "0.2";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "yaw_goal_tolerance";
                    paramset.type = "float";
                    paramset.value = "0.05";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "p_drive";
                    paramset.type = "float";
                    paramset.value = "0.7";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "d_drive";
                    paramset.type = "float";
                    paramset.value = "1.2";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "wp_tolerance";
                    paramset.type = "float";
                    paramset.value = "1";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "avoid";
                    paramset.type = "bool";
                    paramset.value = "false";
                    act.action_params.Add(paramset);

                    paramset = new ParameterSet();
                    paramset.param_name = "ATC_NUMBER";
                    paramset.type = "string";
                    paramset.value = "000";
                    act.action_params.Add(paramset);

                    missiondata.work.Add(act);

                    string strMissionData_Json = JsonConvert.SerializeObject(missiondata);

                    //미션리스트 DB저장
                    mainform.dbBridge.onDBInsert_Missionlist(missionname, missionid, "", "", strMissionData_Json);

                    //화면 갱신
                    

                }

            }
            catch
            {

            }
        }
    }
}
